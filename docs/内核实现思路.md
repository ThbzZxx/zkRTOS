# ZK-RTOS 内核实现思路文档

## 📋 目录

### 核心子系统
1. [任务调度器](#1-任务调度器设计)
2. [内存管理](#2-内存管理设计)
3. [IPC 机制](#3-ipc机制设计)
4. [时间管理](#4-时间管理)
5. [中断管理](#5-中断管理)


---

## 1. 任务调度器设计

### 设计思路

采用业界主流的基于优先级的抢占式调度策略，并辅以同优先级时间片轮转机制，确保高优先级任务能够抢先执行，同时保证相同优先级任务公平共享CPU资源。

- **抢占式调度**：系统总是确保当前运行的任务是最高优先级的就绪任务。当更高优先级的任务进入就绪状态时，调度器立即切换到该任务执行。
- **时间片轮转**：相同优先级的任务共处于同一就绪链表中。当时间片耗尽时，当前任务被移至该优先级链表尾部，调度器选择链表首个任务运行。

### 实现逻辑

调度器的实现围绕几个关键的数据结构和函数：

**就绪任务链表 (ready_list)**：这是一个数组，包含32个双向链表头节点，分别对应32个优先级等级。例如，`ready_list[5]` 指向所有优先级为5的就绪任务组成的链表。这种结构使得按优先级查找任务的效率非常高。

**优先级位图 (priority_active)**：这是一个32位的位图变量。如果优先级P的就绪链表不为空，那么该变量的第P位就会被置1。这使得调度器可以极快地找到当前存在的最高优先级。在 `get_highest_priority_task` 函数中，通过一条高效的 `zk_cpu_clz` 硬件指令（使用RBIT位反转和CLZ计算前导零），就能瞬间定位到最高的就绪优先级，避免了遍历整个 `ready_list` 数组。

```c
__asm static ZK_FORCE_INLINE zk_uint8 zk_cpu_clz(zk_uint32 value)
{
    RBIT    r0, r0      /* 位反转：最低位变最高位 */
    CLZ     r0, r0      /* 计算前导零 = 原最低位1的位置 */
    BX      lr
}
```

**调度函数 (schedule)**：这是调度的核心决策中心。它首先检查调度器是否被挂起，然后使用优先级位图找到最高的就绪优先级任务。如果该任务的优先级高于当前任务，立即触发切换。如果优先级相同且该优先级链表中还有其他任务，它会将当前任务移动到链表的末尾，实现时间片轮转。最后，通过 `zk_cpu_trigger_pendsv()` 触发PendSV异常进行真正的上下文切换。

**延迟调度**：为了最大程度地缩短中断关闭时间和中断响应延迟，zkRTOS采用了延迟调度机制。在中断服务程序或临界区代码中，当任务状态改变需要调度时，系统并不会立即执行上下文切换，而是通过 `zk_cpu_trigger_pendsv()` 触发一个低优先级的PendSV异常。PendSV异常会在所有其他中断处理完毕后才执行，真正的上下文切换逻辑位于 `PendSV_Handler` 中。这确保了中断处理的快速返回，提高了系统的实时性。

**时间片轮转**：在 `scheduler_increment_tick` 函数中，系统节拍中断每次触发时，会检查当前任务是否时间片用完（默认5个tick）。如果用完且同优先级还有其他就绪任务，则将当前任务移至队尾并切换到队首任务，确保同优先级任务公平共享CPU。

---

## 2. 内存管理设计

### 设计思路

zkRTOS采用静态池化技术实现动态内存管理，系统从静态分配的内存池中分配内存，采用首次适应算法和立即合并策略进行内存管理。

### 实现逻辑

内存管理器的实现围绕首次适应和立即合并两大核心机制：

**空闲块链表 (free_list) 和已用块链表 (used_list)**：系统维护两个独立的双向链表。空闲块链表按地址升序排列，这是实现高效合并的关键。每个内存块包含一个12字节的头部（8字节链表节点 + 4字节大小字段），用户数据区紧跟其后。所有块按8字节对齐，最小块大小为16字节。

**首次适应分配算法 (mem_alloc)**：当系统申请内存时，会遍历空闲链表，找到第一个满足大小要求的块。如果该块大小远大于请求大小（至少剩余16字节），则将其分割成两块：一块分配给用户并移入已用链表，另一块作为新的空闲块按地址插回空闲链表。

**立即合并算法 (mem_merge_free_blocks)**：当内存块被释放时，系统首先从已用链表中移除该块，然后在空闲链表中按地址查找插入位置。插入过程中会检查该块是否与前后相邻的空闲块物理连续，如果连续则立即合并成更大的空闲块。这种立即合并策略有效减少了内存碎片，最大程度地保持大块连续内存可用。

**内存统计**：系统实时记录总内存大小、可用内存、峰值使用量、分配次数、失败次数、空闲块数量等统计信息，方便开发者监控和调试内存使用情况。

---

## 3. IPC机制设计

### 设计思路

zkRTOS提供一套健壮的线程安全IPC机制，支持阻塞、非阻塞和带超时的操作模式。所有IPC对象的操作都在临界区内执行，保证原子性。

### 实现逻辑

zkRTOS提供了四种核心IPC机制，均采用统一的阻塞唤醒模型：

**信号量 (Semaphore)**：采用计数器模型，核心函数包括 `sem_get` 和 `sem_release`。当任务获取信号量时，如果计数值大于0则直接减1并返回；如果计数值为0则任务按优先级排序进入等待队列并阻塞。释放信号量时，如果有任务在等待，则唤醒最高优先级的任务而不是增加计数值；如果没有等待任务，则增加计数值，同时支持阻塞、非阻塞和超时三种操作模式。

**互斥锁 (Mutex) - 链式优先级继承**：互斥锁不仅记录当前持有者，还维护了一个 `holding_mutex` 指针链，记录任务正在等待或持有的互斥锁。当高优先级任务等待低优先级任务持有的锁时，会触发 `mutex_priority_inheritance_chain` 函数，该函数沿着锁链向上传播优先级提升。例如：任务A持有Mutex1并等待Mutex2，任务B持有Mutex2，任务C（高优先级）等待Mutex1，则A和B的优先级都会被临时提升到C的优先级，防止优先级反转。互斥锁还支持递归获取，通过 `owner_hold_count` 计数器实现。释放锁时，系统会恢复持有者的原始优先级，并将锁的所有权直接传递给最高优先级的等待任务。

**递归互斥锁**：本质上是带递归计数的互斥锁，允许同一任务多次获取同一锁。每次获取递增 `owner_hold_count`，每次释放递减，只有当计数归零时才真正释放锁并唤醒等待任务。这在需要递归调用的临界区保护中非常有用。

**消息队列 (Queue)**：采用环形缓冲区实现固定大小的消息传递。维护 `read_pos` 和 `write_pos` 两个索引，以及 `reader_sleep_list` 和 `writer_sleep_list` 两个等待队列。写入时如果队列满则任务进入写等待队列阻塞，读取时如果队列空则任务进入读等待队列阻塞。写入成功后唤醒读等待队列的任务，读取成功后唤醒写等待队列的任务，实现了生产者-消费者模式的同步。

**统一的阻塞唤醒机制**：所有IPC操作都通过 `task_ready_to_block` 和 `task_block_to_ready` 进行任务状态转换，支持按优先级或FIFO排序的等待队列，以及带超时的阻塞操作。超时任务会被加入 `block_timeout_list`，由系统节拍中断统一检查唤醒。

---

## 4. 中断管理

### 设计思路

1. **保护内核数据**：191~255 被屏蔽，防止在临界区中发生任务切换或 API 重入
2. **保证实时性**：0~190 不屏蔽，紧急中断仍能响应
**191 的特殊性**:
  由于 Cortex-M3 的优先级寄存器只使用高 4 位（低 4 位被忽略），实际可配置的优先级值为：
  0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240
  191 位于 176 和 192 之间

### 4.1 SysTick 和 PendSV 优先级设置

**配置实现**:
```c
/* zk_def.h 中的配置 */
#define ZK_KERNEL_INTERRUPT_PRIORITY 255       // 内核中断优先级（最低）
#define ZK_MAX_SYSCALL_INTERRUPT_PRIORITY 191  // 系统调用最高可屏蔽优先级

/* zk_cpu_cm3.h 中的宏定义 */
#define ZK_CM3_PENDSV_PRI   (((zk_uint32)ZK_KERNEL_INTERRUPT_PRIORITY) << 16UL)
#define ZK_CM3_SYSTICK_PRI  (((zk_uint32)ZK_KERNEL_INTERRUPT_PRIORITY) << 24UL)

/* zk_cpu_cm3.c 中调度器启动时设置 */
void zk_cpu_cm3_start_scheduler(void) {
    /* 设置 PendSV 和 SysTick 中断优先级为 255（最低）*/
    ZK_CM3_SHPR3_REG |= ZK_CM3_PENDSV_PRI;   // SHPR3[23:16] = 255
    ZK_CM3_SHPR3_REG |= ZK_CM3_SYSTICK_PRI;  // SHPR3[31:24] = 255
    // ...
}
```
1. **SysTick 优先级 255**:
   - SysTick 每毫秒触发一次，优先级过高会频繁打断用户中断
   - 1ms 的时间精度对大多数应用足够，延迟几微秒不影响系统稳定性
   - 允许紧急硬件中断抢占 SysTick，保证实时事件能及时响应

2. **PendSV 优先级 255**:
   - 上下文切换需要保存/恢复 16 个寄存器，耗时较长
   - 必须在所有中断处理完毕后再执行，避免在中断嵌套中切换任务
   - 延迟调度机制的核心：SysTick 或 API 触发 PendSV，等所有中断返回后才真正切换

### 4.2 临界区 BASEPRI 值（191）详解

**临界区实现**:
```c
/* zk_cpu_cm3.h */
static ZK_FORCE_INLINE void zk_cpu_enter_critical(void)
{
    zk_uint32 basepri = ZK_MAX_SYSCALL_INTERRUPT_PRIORITY;  // 191
    __asm
    {
        msr basepri, basepri    // 设置 BASEPRI = 191
        dsb                      // 数据同步屏障
        isb                      // 指令同步屏障
    }
    zk_critical_nesting++;
}

static ZK_FORCE_INLINE void zk_cpu_exit_critical(void)
{
    zk_critical_nesting--;
    if (zk_critical_nesting == 0)
    {
        zk_uint32 basepri_zero = 0;
        __asm { msr basepri, basepri_zero }  // 恢复中断
    }
}
```

---

## 5. 时间管理

### 设计思路

提供可靠的基于系统节拍的时间服务，实现精确的任务唤醒和超时管理。

### 实现逻辑

zkRTOS的时间管理建立在系统节拍和精确的任务唤醒机制之上：

**SysTick配置与中断处理**：系统使用Cortex-M的SysTick定时器产生固定周期的系统节拍（1ms）。设置SysTick和PendSV为最低优先级。每次SysTick中断触发时，调用 `scheduler_increment_tick` 函数，该函数增加全局时间计数器 `g_current_time`，然后依次检查延时任务和超时阻塞任务的唤醒。

**延时任务管理 (delay_list)**：当任务调用 `task_delay` 时，系统计算唤醒时间后将任务按唤醒时间升序插入 `delay_list`。在系统节拍中断中遍历延时队列头部，将所有到期任务（`time >= wake_up_time`）移入就绪队列。由于队列有序，遇到第一个未到期任务即可停止遍历。

**超时阻塞管理 (block_timeout_list)**：当任务在IPC操作中指定超时时间时，除了进入IPC对象的等待队列，还会同时加入调度器的 `block_timeout_list`。该链表同样按唤醒时间升序排列。在 `check_task_block_wakeup` 函数中，系统检查超时任务并标记唤醒状态， 然后将任务从阻塞状态恢复到就绪状态，任务被唤醒后会检查该标志并返回超时错误。

**时间溢出处理**：由于使用32位计数器，系统约49.7天后会溢出。zkRTOS采用带符号比较宏来处理溢出：
`zk_time_is_reached(now, target (((long)(now) - (long)(target)) >= 0)`。这种方法利用补码运算的特性，即使在溢出时也能正确比较时间先后关系。

**软件定时器**：系统提供软件定时器功能，定时器按超时时间升序排列在 `timers_list` 中。在 `timer_check` 函数中（由SysTick调用），系统将到期的定时器移到临时的 `expired_list`，然后在非临界区执行定时器回调函数，最后根据定时器模式（单次或循环）决定是否重新加入队列。这种设计缩短了临界区时间，允许定时器回调中进行阻塞操作。

---
